---
title: CSAPP：BOMB实验
date: 2020-12-9 20:08:50
categories: 实验记录
tags:
- 计算机基础
- Csapp
- 汇编语言
- Linux
cover: /Images/20.jpg
---

-------
### 实验开始
炸弹实验是`CSAPP`的第二个实验，涉及到了`反汇编`、`读懂汇编语言`、`Linux下GDB的使用`及`C语言`，其中的读懂汇编语言是重难点，完整的看懂了一个函数的汇编语言时，炸弹也迎刃而解。

每个人得到的BOMB都是不一样的，大体上是每种类型的炸弹都有不同的题目，共六个`PHASE` + `一个SECRET_PHASE`, 也就是七个炸弹。具体内容后面再说。每个人的BOMB都不一样，但是大体就那么几个在哪排列组合，所以花时间使用BAIDU GOOGLE的话还是可以找到原题的，但是并没有什么卵用，直接抄的话。按我们老师说就是学术剽窃，就是学术作弊。当然可以借鉴一下，毕竟不认真研究一下汇编，是真的不怎么好做这BOMB实验。最好还是自己慢慢看懂汇编，翻译成原来的C语言代码，再得到密码解除炸弹，这样子的收获才是最大的。

实验的资料自己都有哦，懂得都懂。  

### 实验过程
#### 实验概述

+ 逆向工程拆除“二进制炸弹”程序  
+ 增强对程序机器级表示、汇编语言、调试器和逆向工程等理解。  
+ 一个“Binary Bombs”（二进制炸弹，简称炸弹）是一个Linux可执行C程序，包含phase1~phase6共6个阶段。  
+ 炸弹运行各阶段要求输入一个字符串，若输入符合程序预期，该阶段炸弹被“拆除”，否则“爆炸” 。  
+ 你需要拆除尽可能多的炸弹。  

#### 实验介绍  
每个炸弹阶段考察机器级语言程序不同方面，难度递增  
+ 阶段1：字符串比较
+ 阶段2：循环
+ 阶段3：条件/分支：含switch语句
+ 阶段4：递归调用和栈
+ 阶段5：指针
+ 阶段6：链表/指针/结构
+ 隐藏阶段：第4阶段之后附加特定字符串后出现

好家伙，老师提供的PPT里就直接说明了，以上内容，尤其是隐藏阶段，即SECRET_PHASE，在哪出现和出现的条件。 = =  

#### 实验技能
+ 拆弹装备：
  + 熟练使用gdb调试器和objdump；
  + 单步跟踪调试每一阶段的机器代码；
  + 理解汇编语言代码的行为或作用；
  + “推断”拆除炸弹所需的目标字符串。
  + 在各阶段的开始代码前和引爆炸弹函数前设置断点，便于调试。
+ 实验语言：C语言，at&t汇编语言
+ 实验环境：32位 linux  

#### 实验文件说明
+ 炸弹文件包：（每个人的不一样）
+ $tar vxf bomb_2017.tar
  + bomb：   bomb的可执行程序。
  + bomb.c：bomb程序的main函数。
  + README
+ bomb：是一个linux下可执行程序，需要0或1个命令行参数
  + 不带参数运行，输出欢迎信息后，期待你按行输入                拆弹字符串，错误炸弹引爆退出，正确提示进入下一关。
  + 带参数运行，从拆弹者的密码文件中读取用户密码
+ bomb.c：bomb主程序，帮助拆弹者了解代码框架，没有细节

#### 拆弹方式
+ 方法1：$./bomb 
  + 根据提示，逐阶段手工输入拆弹字符串（见演示）
  + 较为繁琐，重复工作多

![方法一演示](/csapp-bomb/bomb1.png)
+ 方法2：$./bomb ans.txt     （推荐）
  + ans.txt为拆弹密码文本文件，名字可以自定义
    + 文本文件，每个拆弹字符串一行，回车结束，最多7行
    + 除此之外不要包含任何其它字符
  + 程序会检查每一阶段的拆弹密码字符串来决定炸弹拆除成败。

![方法二演示](/csapp-bomb/bomb2.png)  

这样子是真的快！ 
```terminal
$ ./bomb ans.txt
```

### 开始拆弹  
首先反汇编`bomb`
```ter
$ objdump –d bomb > asm.txt
```
对bomb进行反汇编并将汇编代码输出到asm.txt中。  

然后查看汇编文件`asm.txt`。寻找`phase`所在的汇编代码段。 

#### Phase_1

在`asm.txt`的`main`函数中找到如下语句
这里为`phase1`函数在`main()`函数中被调用的位置：

```
 8048a9a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048aa1:	e8 ea fd ff ff       	call   8048890 <__printf_chk@plt>
 8048aa6:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
 8048aad:	e8 7e fd ff ff       	call   8048830 <exit@plt>
 8048ab2:	e8 7c 06 00 00       	call   8049133 <initialize_bomb>
 8048ab7:	c7 04 24 cc a1 04 08 	movl   $0x804a1cc,(%esp)
 8048abe:	e8 2d fd ff ff       	call   80487f0 <puts@plt>
 8048ac3:	c7 04 24 08 a2 04 08 	movl   $0x804a208,(%esp)
 8048aca:	e8 21 fd ff ff       	call   80487f0 <puts@plt>
 8048acf:	e8 7d 07 00 00       	call   8049251 <read_line>
 8048ad4:	89 04 24             	mov    %eax,(%esp)
 8048ad7:	e8 b4 00 00 00       	call   8048b90 <phase_1>
                                                   //phase_1的位置，往下翻找即可
 8048adc:	e8 6e 08 00 00       	call   804934f <phase_defused>
 8048ae1:	c7 04 24 34 a2 04 08 	movl   $0x804a234,(%esp)
 ```
然后再就是`phase_1`:  
```
08048b90 <phase_1>:
 8048b90:	55                   	push   %ebp
 8048b91:	89 e5                	mov    %esp,%ebp
 8048b93:	83 ec 18             	sub    $0x18,%esp
 8048b96:	c7 44 24 04 84 a2 04 	movl   $0x804a284,0x4(%esp)
 8048b9d:	08 
 8048b9e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048ba1:	89 04 24             	mov    %eax,(%esp)
 8048ba4:	e8 19 05 00 00       	call   80490c2 <strings_not_equal>
 8048ba9:	85 c0                	test   %eax,%eax
 8048bab:	74 05                	je     8048bb2 <phase_1+0x22>
 8048bad:	e8 25 06 00 00       	call   80491d7 <explode_bomb>
 8048bb2:	c9                   	leave  
 8048bb3:	c3                   	ret    
```